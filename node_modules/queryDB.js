/**
 * Created by XiTU on 1/28/14.
 */

// declare and define all the variables used in the module
var constants = require('./constants');
var tableNames = require('./tableNames');
var dbPool = require('./createDBConnectionPool');
var async = require('async');
var cache = require('memory-cache');
var runQuery = dbPool.runQuery;
var runQueryWithParams = dbPool.runQueryWithParams;
var connection = dbPool.connection;

var timeoutInMilliSeconds = 1000*60*60*24;  //timeout in 1 day


/****************************************************
 * Common utility for getAll functions
 * return all the requested data in json format.
 * Searching in Cache first, with key @tableName
 *  if key doesn't exist, query from DB, and
 *   then put the key/value pair into Cache
 * @param tableName
 *     the table name which we need to extract from
 * @param callback
 *     callback function to process the results
 ****************************************************/
function getAllFromCacheOrDB(tableName,whereClause,callback) {
    var data = cache.get(tableName);
    //First get the data from cache,
    //if there's no data in cache, query from DB and then put it into cache.
    if(data) {
        console.log("Cache hits, getting " +tableName+ " from Cache.");
        callback(data);
    } else {
        var sql = " select * from "+tableName+" "+whereClause;
        runQuery(sql,function(results){
            console.log("Cache missing, querying scenerySpots from DB.");
            cache.put(tableName,results,timeoutInMilliSeconds);
            callback(results);
        });
    }
}

/**********************************************
 * getAll% methods
 * @param callback
 *     callback function to process the results
 **********************************************/

exports.getAllScenerySpots = function(callback) {

    getAllFromCacheOrDB(tableNames.spotTable,"",callback);
}

exports.getAllRoutes = function(callback) {

    getAllFromCacheOrDB(tableNames.routeTable,"",callback);
}

exports.getAllTickets = function(callback) {
    getAllFromCacheOrDB(tableNames.ticketTable,"",callback);
}

exports.getAllBuses = function(callback) {
    getAllFromCacheOrDB(tableNames.busTable,"",callback);
}

exports.getAllDrivers = function(callback) {
    getAllFromCacheOrDB(tableNames.driverTable,"",callback);
}

//all schedules with date null or later than today
exports.getAllValidSchedules = function(callback) {

    var whereClause = " where date is null or date >= now()";
    getAllFromCacheOrDB(tableNames.scheduleTable,whereClause,callback);

}


exports.getAllOffers = function(callback) {

    var results
    var getTicketOffer=" select * from " + tableNames.offerTable +" ot inner join "+
        tableNames.mappingTable + " mp on ot.offer_id = mp.offerId " +" inner join " +
        tableNames.ticketTable + "ticket on mp.sku_id on ticket.sku_id where mp.type='Ticket' ";


    var sqls = {
        'insertSQL': 'insert into t_user(name) values("conan"),("fens.me")',
        'selectSQL': 'select * from t_user limit 10',
        'deleteSQL': 'delete from t_user',
        'updateSQL': 'update t_user set name="conan update"  where name="conan"'
    };

    var tasks = ['deleteSQL', 'insertSQL', 'selectSQL', 'updateSQL', 'selectSQL'];
    async.eachSeries(tasks, function (item, callback) {
        console.log(item + " ==> " + sqls[item]);
        conn.query(sqls[item], function (err, res) {
            console.log(res);
            callback(err, res);
        });
    }, function (err) {
        console.log("err: " + err);
    });


}

exports.getAllCustomers = function(callback){

}

exports.getAllValidVouchers = function(callback) {

}
/*

//First check if there's any override date, if not, use null date
exports.getScheduleForRoute = function(sku_id, date, callback) {

    var sql = "select * from " + tableNames.scheduleTable + " where sku_id= ? and ( date = ? || date is null) ";

    var userInput = [sku_id, date];
    runQueryWithParams(sql,userInput,callback);

}

exports.getOrderFromConfirmationCode = function(confirmationCode, spotId, date, timeSlot, callback) {
    //var sql = " select order_id from "+orderTable+" where confirmation_code="+confirmationCode;

    var sqlValidate = "update "+tableNames.ticketTable+" set is_valid='N', redeem_datetime=sysdate() where confirmation_code=? and spot_Id=? and valid_date=?  and time_slot=? and (is_valid='Y' or is_valid is NULL) ";

    var userInput=[confirmationCode,spotId,date,timeSlot];

    runQueryWithParams(sqlValidate,userInput,callback);

}

exports.getOrderFromPhone = function(phoneNumber, callback) {

}

//userInfo. (Json:  email,phone,name
//orderInfo (JsonArray: spot_id,valid_date,quantity_price)
exports.placeOrder = function(userInfo, orderInfoArray, confirmationCode, status, callback){

    console.log("confirmationCode:"+confirmationCode);
    var sqlInsertOrder = "insert into "+orderTable+" (email,phone,name,order_total_amount,confirmation_code,order_status) values (?,?,?,?,?,?)";
    var sqlInsertTicket = "insert into "+ticketTable+" (confirmation_code,spot_id,valid_date,departure,quantity, total_amount,time_slot) values (?,?,?,?,?,?,?) ";

    var userInput=[userInfo.email,userInfo.phone,userInfo.name,userInfo.order_total_amount,confirmationCode,status];
    console.log("userInput--"+userInput);
    pool.getConnection(function(err,connection){
        if(err) {console.log(err); callback(0); return;}

        connection.query(sqlInsertOrder,userInput,function(err,info){
            if(err) {connection.rollback();console.log("transaction rolled back!");throw err;}
            console.log("info.affectedRows=" + info.affectedRows);



            if(info.affectedRows>0) {
                var count=0;
                console.log("o_length=" + orderInfoArray.length);
                for(var i=0;i<orderInfoArray.length;++i) {
                    var ticketInfo=[];
                    console.log("i=" + i);
                    ticketInfo[0]=confirmationCode;
                    ticketInfo[1]=orderInfoArray[i].spot_id;
                    ticketInfo[2]=orderInfoArray[i].valid_date;
                    ticketInfo[3]=orderInfoArray[i].departure;
                    ticketInfo[4]=orderInfoArray[i].quantity;
                    ticketInfo[5]=orderInfoArray[i].total_amount;
                    ticketInfo[6]=orderInfoArray[i].time_slot;

                    console.log("timeSlot=" + orderInfoArray[i].time_slot);
                    connection.query(sqlInsertTicket,ticketInfo,function(err,info){
                        if(err){ connection.rollback();console.log("transaction rolled back!");throw err;}
                        callback(info.affectedRows);
                        ++count;
                        if(count==orderInfoArray.length) {
                            connection.release();
                            console.log("all transaction finished!");
                            callback(1);
                            // pool.end(function (err) {
                            //     if (err) console.error("An error occurred: " + err);
                            //     else console.log("My app terminated");
                            // });
                        }
                    })
                }
            }

            //connection.end();
        })
    })
}

exports.checkOrder=function(confirmationCode,callback) {
    var sqlCheckOrder = "select t_scenery_spots.spot_name, t_orders.*,t_tickets_sold.* from t_tickets_sold,t_orders, t_scenery_spots where t_tickets_sold.confirmation_code = t_orders.confirmation_code and t_scenery_spots.spot_id= t_tickets_sold.spot_id and t_orders.confirmation_code = ? and is_valid='Y' ";

    runQueryWithParams(sqlCheckOrder,[confirmationCode],callback);

}
*/


/***************************************
/* Admin functionalities
/***************************************/

exports.addScenerySpot = function(spotId,date,time_slot,callback){
    var sql="";
    runQueryWithParams(sqlCheckInventory,[spotId,date,time_slot],callback);

}